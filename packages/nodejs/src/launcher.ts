import { Runtime } from '@function-bay/build';

export let getMetorialLauncher = async (opts: { bundledEntrypoint: string }) => {
  if (Runtime.provider == 'aws.lambda') {
    return {
      handler: 'metorial_launcher.handler',
      entrypoint: 'metorial_launcher.js',
      files: [
        {
          filename: 'metorial_launcher.js',
          content: `// Auto-generated by Metorial Function Bay
import * as handlerModule from './${opts.bundledEntrypoint}';

let handlerFunc = handlerModule;

export let handler = async (event) => {
  if (typeof handlerFunc == 'object') {
    if (typeof handlerFunc.default === 'function') {
      handlerFunc = handlerFunc.default;
    } else if (typeof handlerFunc.handler === 'function') {
      handlerFunc = handlerFunc.handler;
    }
  }

  if (typeof handlerFunc !== 'function') {
    return {
      statusCode: 500,
      body: { error: { code: 'function_bay.launcher', message: "Entrypoint does not export a valid handler function" } }
    };
  }

  let rawPayload = event.payload;
  if (!rawPayload) {
    return {
      statusCode: 400,
      body: { error: { code: 'function_bay.launcher', message: "Missing payload field" } }
    };
  }

  let data = rawPayload;
  if (typeof rawPayload === 'string') {
    try {
      data = JSON.parse(rawPayload);
    } catch (err) {
      return {
        statusCode: 400,
        body: { error: { code: 'function_bay.launcher', message: "Invalid JSON payload" } }
      };
    }
  }

  try {
    let result = await handlerFunc(data);

    return {
      statusCode: 200,
      body: { result }
    };
  } catch (err) {          
    if (typeof err == 'object' && err.__function_bay_error) {
      let result = err.toResponse();
      return {
        statusCode: 500,
        body: { error: result }
      };
    }

    console.error(err);

    let fullMessage = '';
    if (typeof err == 'object' && err !== null) {
      if ('name' in err && typeof err.name === 'string') {
        fullMessage += \`[\${err.name}]: \\n\`;
      }

      if ('message' in err && typeof err.message === 'string') {
        fullMessage += err.message;
      }

      if ('stack' in err && typeof err.stack === 'string') {
        fullMessage += '\\n' + err.stack;
      }
    } else {
      try {
        fullMessage = JSON.stringify(err);
      } catch {
        fullMessage = String(err || 'Unknown error');
      }
    }

    return {
      statusCode: 500,
      body: { error: { code: 'function_bay.handler_error', message: fullMessage } }
    };
  }
};
`
        },

        {
          filename: 'tsconfig.json',
          content: JSON.stringify(
            {
              compilerOptions: {
                lib: ['ESNext', 'DOM', 'DOM.Iterable'],
                target: 'es2020',
                jsx: 'react-jsx',
                allowJs: true,
                moduleResolution: 'bundler',
                verbatimModuleSyntax: false,
                strict: false,
                skipLibCheck: true,
                noFallthroughCasesInSwitch: false,
                noUncheckedIndexedAccess: false,
                noImplicitOverride: false,
                noUnusedLocals: false,
                noUnusedParameters: false,
                noPropertyAccessFromIndexSignature: false
              }
            },
            null,
            2
          )
        }
      ]
    };
  }

  throw new Error(`Unsupported provider for Node.js runtime: ${Runtime.provider}`);
};
