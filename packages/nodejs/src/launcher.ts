import { Runtime } from '@function-bay/build';

export let getMetorialLauncher = async (opts: { bundledEntrypoint: string }) => {
  if (Runtime.provider == 'aws.lambda') {
    return {
      handler: 'metorial_launcher.handler',
      entrypoint: 'metorial_launcher.js',
      files: [
        {
          filename: 'metorial_launcher.js',
          content: `// Auto-generated by Metorial Function Bay
import * as handlerModule from './${opts.bundledEntrypoint}';

let handler = handlerModule;

exports.handler = async (event) => {
  // Load the entrypoint module
  if (typeof handler == 'object') {
    if (typeof handler.default === 'function') {
      handler = handler.default;
    } else if (typeof handler.handler === 'function') {
      handler = handler.handler;
    }
  }

  if (typeof handler !== 'function') {
    return {
      statusCode: 500,
      body: JSON.stringify({ error: { code: 'function_bay.launcher', message: "Entrypoint does not export a valid handler function" } })
    };
  }

  let rawPayload = event.payload;
  if (!rawPayload) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: { code: 'function_bay.launcher', message: "Missing payload field" } })
    };
  }

  let data;
  try {
    data = JSON.parse(rawPayload);
  } catch (err) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: { code: 'function_bay.launcher', message: "Invalid JSON payload" } })
    };
  }

  try {
    let result = await handler(data);

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: "Payload received",
        received: data
      })
    };
  } catch (err) {
    if (typeof err == 'object' && err.__function_bay_error) {
      let result = err.toResponse();
      return {
        statusCode: result.statusCode || 500,
        body: JSON.stringify(result)
      };
    }

    let fullMessage = '';
    if (typeof err == 'object' && err !== null) {
      if ('name' in err && typeof err.name === 'string') {
        fullMessage += \`[\${err.name}]: \\n\`;
      }

      if ('message' in err && typeof err.message === 'string') {
        fullMessage += err.message;
      }

      if ('stack' in err && typeof err.stack === 'string') {
        fullMessage += '\\n' + err.stack;
      }
    } else {
      try {
        fullMessage = JSON.stringify(err);
      } catch {
        fullMessage = String(err || 'Unknown error');
      }
    }

    return {
      statusCode: 500,
      body: JSON.stringify({ error: { code: 'function_bay.handler_error', message: fullMessage } })
    };
  }
};
`
        },

        {
          filename: 'tsconfig.json',
          content: JSON.stringify(
            {
              compilerOptions: {
                lib: ['ESNext'],
                target: 'es2020',
                jsx: 'react-jsx',
                allowJs: true,
                moduleResolution: 'bundler',
                verbatimModuleSyntax: false,
                strict: false,
                skipLibCheck: true,
                noFallthroughCasesInSwitch: false,
                noUncheckedIndexedAccess: false,
                noImplicitOverride: false,
                noUnusedLocals: false,
                noUnusedParameters: false,
                noPropertyAccessFromIndexSignature: false
              }
            },
            null,
            2
          )
        }
      ]
    };
  }

  throw new Error(`Unsupported provider for Node.js runtime: ${Runtime.provider}`);
};
